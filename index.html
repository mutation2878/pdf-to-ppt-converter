<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NotebookLM PDF è½‰ PPT ç°¡å ±ç”Ÿæˆå™¨ (V5+ è¦–è¦ºä¿®å¾©ç‰ˆ)</title>
    <link rel="manifest" href="manifest.json">
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js');
  }
</script>
    <!-- å¼•å…¥å¿…è¦çš„å‡½å¼åº« -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        body { font-family: 'Noto Sans TC', sans-serif; background-color: #f3f4f6; }
        .page-card { transition: all 0.3s ease; }
        .page-card.active { border: 2px solid #3b82f6; box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.5); }
        .page-card.done { border-color: #10b981; background-color: #ecfdf5; }
        .page-card.error { border-color: #ef4444; background-color: #fef2f2; }
        
        /* é˜²æ­¢ç•«å¸ƒæ“ä½œæ™‚æ²å‹•é é¢ */
        canvas { touch-action: none; }
        
        /* å¸ç®¡æ¨¡å¼æ¸¸æ¨™ */
        .cursor-pipette { cursor: crosshair !important; }

        .loader {
            border: 3px solid #f3f3f3;
            border-radius: 50%;
            border-top: 3px solid #3b82f6;
            width: 20px;
            height: 20px;
            -webkit-animation: spin 1s linear infinite; /* Safari */
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-white shadow-sm z-10 p-4 flex flex-col gap-3">
        <div class="flex justify-between items-center">
            <div class="flex items-center gap-3">
                <div class="bg-blue-600 text-white p-2 rounded-lg font-bold text-xl">N</div>
                <h1 class="text-xl font-bold text-gray-800">PDF è½‰ PPT ç°¡å ±ç”Ÿæˆå™¨ <span class="text-xs font-normal text-gray-500 bg-gray-100 px-2 py-1 rounded">V5+ è¦–è¦ºä¿®å¾©ç‰ˆ</span></h1>
            </div>
            
            <div class="flex gap-4 items-center">
                <div class="flex flex-col items-end">
                    <label class="text-xs text-gray-500 mb-1">Google Gemini API Key</label>
                    <input type="password" id="apiKey" class="border rounded px-2 py-1 text-sm w-64 focus:outline-none focus:border-blue-500" placeholder="è²¼ä¸Šæ‚¨çš„ API Key (AIza...)">
                </div>
                <label class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded cursor-pointer transition flex items-center gap-2">
                    <i data-lucide="folder-open" class="w-4 h-4"></i>
                    <span>é¸æ“‡ PDF</span>
                    <input type="file" id="pdfInput" accept=".pdf" class="hidden">
                </label>
                <button id="downloadBtn" onclick="exportPPT()" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2" disabled>
                    <i data-lucide="download" class="w-4 h-4"></i>
                    <span>ä¸‹è¼‰ PPT</span>
                </button>
            </div>
        </div>
        
        <!-- V5 åŒ¯å‡ºèªªæ˜ -->
        <div class="flex justify-end gap-4 text-sm text-gray-600 bg-gray-50 p-2 rounded border border-gray-100 items-center">
            <span class="font-bold text-blue-800 self-center">ğŸ’¡ V5+ åŠŸèƒ½ï¼š</span>
            <span>é»æ“Šã€Œå¸ç®¡ã€å–è‰² -> ç”¨ã€Œç­†åˆ·ã€å¡—æ‰èˆŠå­— -> AI æ–°å­—æœƒç–Šåœ¨ä¸Šé¢ã€‚</span>
            <label class="flex items-center gap-2 cursor-pointer hover:text-blue-600 border-l pl-4 ml-2">
                <input type="checkbox" id="useBgImage" class="rounded text-blue-600 focus:ring-blue-500" checked>
                <span>åŒ¯å‡ºä¿ç•™åŸå§‹åº•åœ–</span>
            </label>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex overflow-hidden">
        
        <!-- Left: Preview & List -->
        <div class="w-1/3 bg-white border-r flex flex-col">
            <div class="p-3 bg-gray-50 border-b flex flex-col gap-3">
                
                <!-- Status Row -->
                <div class="flex justify-between items-center">
                    <span id="pageCount" class="font-bold text-gray-700">ç­‰å¾…æª”æ¡ˆ...</span>
                </div>

                <!-- Range Selector -->
                <div id="rangeSelector" class="hidden flex flex-col gap-2 text-sm bg-gray-100 p-2 rounded">
                    <div class="flex items-center gap-3">
                        <span class="font-bold text-gray-600">è™•ç†ç¯„åœï¼š</span>
                        <label class="flex items-center gap-1 cursor-pointer">
                            <input type="radio" name="rangeType" value="all" checked onchange="toggleRangeInput()" class="text-blue-600"> å…¨éƒ¨
                        </label>
                        <label class="flex items-center gap-1 cursor-pointer">
                            <input type="radio" name="rangeType" value="custom" onchange="toggleRangeInput()" class="text-blue-600"> æŒ‡å®šé æ•¸
                        </label>
                    </div>
                    <input type="text" id="customRangeInput" disabled placeholder="ä¾‹å¦‚: 1, 3, 5-8 (åŠå½¢æ•¸å­—)" class="border rounded px-2 py-1 w-full text-xs disabled:bg-gray-200 disabled:text-gray-400 focus:ring-2 focus:ring-blue-300 outline-none">
                </div>

                <!-- Buttons & Status -->
                <div id="controlPanel" class="hidden flex flex-col gap-2">
                    <div class="flex gap-2">
                        <button id="autoRunBtn" onclick="startAutoRun()" class="bg-indigo-600 hover:bg-indigo-700 text-white text-xs px-3 py-2 rounded flex-1 flex items-center justify-center gap-1">
                            <i data-lucide="rocket" class="w-3 h-3"></i> è‡ªå‹•åˆ†æ
                        </button>
                        <button id="stopBtn" onclick="stopAutoRun()" class="bg-red-500 hover:bg-red-600 text-white text-xs px-3 py-2 rounded hidden flex-1 flex items-center justify-center gap-1">
                            <i data-lucide="square" class="w-3 h-3"></i> åœæ­¢
                        </button>
                    </div>
                </div>
                <div id="statusMsg" class="bg-yellow-50 text-yellow-800 text-xs p-2 rounded text-center hidden border border-yellow-200">
                    æº–å‚™å°±ç·’
                </div>
            </div>
            
            <div id="pagesList" class="flex-1 overflow-y-auto p-4 space-y-4">
                <div class="text-center text-gray-400 mt-10">
                    è«‹å…ˆä¸Šå‚³ PDF æª”æ¡ˆ<br>
                    <span class="text-xs text-gray-300">V5+ æ”¯æ´å¸ç®¡èˆ‡å®Œæ•´é è¦½</span>
                </div>
            </div>
        </div>

        <!-- Right: Editor/Details -->
        <div class="w-2/3 bg-gray-50 p-8 overflow-y-auto flex flex-col items-center">
            <div id="previewArea" class="w-full max-w-5xl bg-white shadow-lg rounded-lg min-h-[600px] p-6 hidden">
                <div class="flex justify-between items-start mb-4 border-b pb-2">
                    <div>
                        <h2 class="text-2xl font-bold text-gray-800">ç·¨è¼¯èˆ‡é®è“‹</h2>
                        <p class="text-gray-500 text-sm">è«‹ä½¿ç”¨ç­†åˆ·å¡—æ‰èˆŠæ–‡å­—ï¼ŒAI ç”¢ç”Ÿçš„æ–°å­—æœƒç–Šåœ¨ä¸Šé¢ã€‚</p>
                    </div>
                    <div class="text-right">
                        <span id="currentStatusBadge" class="bg-gray-200 text-gray-700 px-3 py-1 rounded-full text-sm font-medium">æœªåˆ†æ</span>
                    </div>
                </div>

                <div class="grid grid-cols-5 gap-6 h-full">
                    <!-- Image & Canvas Container (Col Span 3) -->
                    <div class="col-span-3">
                        <!-- Toolbar -->
                        <div class="flex items-center gap-2 mb-2 bg-gray-100 p-2 rounded">
                            <span class="text-xs font-bold text-gray-600 flex items-center gap-1">
                                <i data-lucide="brush" class="w-3 h-3"></i> ç­†åˆ·:
                            </span>
                            
                            <!-- æ–°å¢ï¼šå¸ç®¡æŒ‰éˆ• -->
                            <button id="eyedropperBtn" onclick="toggleEyedropper()" class="p-1 border rounded bg-white hover:bg-gray-100 text-gray-700 flex items-center justify-center transition-colors" title="å¸ç®¡å·¥å…·: å¸å–èƒŒæ™¯é¡è‰²">
                                <i data-lucide="pipette" class="w-4 h-4"></i>
                            </button>

                            <input type="color" id="brushColor" value="#FFFFFF" class="h-6 w-8 p-0 border rounded cursor-pointer" title="ç­†åˆ·é¡è‰²">
                            <input type="range" id="brushSize" min="5" max="50" value="20" class="w-24" title="ç­†åˆ·ç²—ç´°">
                            <button onclick="clearMask()" class="text-xs bg-white border px-2 py-1 rounded hover:bg-gray-50 text-red-600 flex items-center gap-1 ml-auto" title="æ¸…é™¤æ‰€æœ‰å¡—é´‰">
                                <i data-lucide="trash-2" class="w-3 h-3"></i> æ¸…é™¤
                            </button>
                        </div>

                        <!-- Canvas Stack -->
                        <!-- â˜…â˜…â˜… ä¿®æ­£ï¼šåŠ å…¥ max-width, max-height, object-fit ç¢ºä¿å®Œæ•´é¡¯ç¤º â˜…â˜…â˜… -->
                        <div class="relative border rounded-lg bg-gray-200 overflow-hidden flex justify-center items-center" style="min-height: 400px; max-height: 650px;">
                            <!-- PDF Layer -->
                            <canvas id="previewCanvas" class="absolute z-10 shadow-sm" style="max-width: 100%; max-height: 100%; object-fit: contain;"></canvas>
                            <!-- Mask Layer (For drawing) -->
                            <canvas id="maskCanvas" class="absolute z-20 cursor-crosshair touch-none" style="max-width: 100%; max-height: 100%; object-fit: contain;"></canvas>
                        </div>
                    </div>

                    <!-- Form (Col Span 2) -->
                    <div class="col-span-2 space-y-4 flex flex-col">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">æŠ•å½±ç‰‡æ¨™é¡Œ</label>
                            <input type="text" id="slideTitle" class="w-full border rounded p-2 focus:ring-2 focus:ring-blue-500 outline-none">
                        </div>
                        <div class="flex-1">
                            <label class="block text-sm font-medium text-gray-700 mb-1">å…§æ–‡é‡é» (æ¯è¡Œä¸€é»)</label>
                            <textarea id="slideContent" class="w-full border rounded p-2 focus:ring-2 focus:ring-blue-500 outline-none h-64 resize-none"></textarea>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">è¬›è€…å‚™å¿˜ç¨¿</label>
                            <textarea id="slideNotes" rows="3" class="w-full border rounded p-2 focus:ring-2 focus:ring-blue-500 outline-none bg-yellow-50"></textarea>
                        </div>
                        <div class="pt-2 flex justify-end">
                            <button onclick="saveCurrentSlide()" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 flex items-center gap-2">
                                <i data-lucide="save" class="w-4 h-4"></i> ä¿å­˜ä¿®æ”¹
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Empty State -->
            <div id="emptyState" class="flex flex-col items-center justify-center h-full text-gray-400">
                <i data-lucide="mouse-pointer-click" class="w-16 h-16 mb-4 text-gray-300"></i>
                <p class="text-lg">é¸æ“‡å·¦å´é é¢é–‹å§‹ç·¨è¼¯</p>
            </div>
        </div>
    </main>

    <!-- JS Logic -->
    <script>
        // Init icons safely
        if (typeof lucide !== 'undefined') lucide.createIcons();
        
        let pdfDoc = null;
        let pdfPages = []; 
        let currentPageIndex = -1;
        let isAutoRunning = false;

        // Canvas Drawing Variables
        let isDrawing = false;
        let isEyedropperActive = false; // å¸ç®¡ç‹€æ…‹
        let lastX = 0;
        let lastY = 0;
        const maskCanvas = document.getElementById('maskCanvas');
        const maskCtx = maskCanvas.getContext('2d');

        const apiKeyInput = document.getElementById('apiKey');
        const fileInput = document.getElementById('pdfInput');
        const pagesList = document.getElementById('pagesList');
        const previewArea = document.getElementById('previewArea');
        const emptyState = document.getElementById('emptyState');
        const statusMsg = document.getElementById('statusMsg');

        // Form elements
        const slideTitle = document.getElementById('slideTitle');
        const slideContent = document.getElementById('slideContent');
        const slideNotes = document.getElementById('slideNotes');

        // Options
        const useBgImageCheck = document.getElementById('useBgImage');
        const customRangeInput = document.getElementById('customRangeInput');
        
        // Brush Tools
        const brushColorInput = document.getElementById('brushColor');
        const brushSizeInput = document.getElementById('brushSize');
        const eyedropperBtn = document.getElementById('eyedropperBtn');

        // --- æ ¸å¿ƒï¼šåº§æ¨™è½‰æ› (è§£æ±ºç¸®æ”¾èˆ‡åç§»å•é¡Œ) ---
        function getCanvasPoint(e, canvas) {
            const rect = canvas.getBoundingClientRect();
            // è¨ˆç®— Canvas å¯¦éš›åƒç´ èˆ‡é¡¯ç¤ºå¤§å°çš„æ¯”ä¾‹
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // æ”¯æ´æ»‘é¼ èˆ‡è§¸æ§
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // Setup Drawing Events
        maskCanvas.addEventListener('mousedown', startDrawing);
        maskCanvas.addEventListener('mousemove', draw);
        maskCanvas.addEventListener('mouseup', stopDrawing);
        maskCanvas.addEventListener('mouseout', stopDrawing);
        
        // Touch support
        maskCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startDrawing(e);
        }, { passive: false });
        maskCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            draw(e);
        }, { passive: false });
        maskCanvas.addEventListener('touchend', stopDrawing);

        // --- å¸ç®¡åŠŸèƒ½é‚è¼¯ ---
        function toggleEyedropper() {
            isEyedropperActive = !isEyedropperActive;
            if (isEyedropperActive) {
                eyedropperBtn.classList.add('bg-blue-100', 'border-blue-500', 'text-blue-600');
                maskCanvas.classList.add('cursor-pipette');
            } else {
                eyedropperBtn.classList.remove('bg-blue-100', 'border-blue-500', 'text-blue-600');
                maskCanvas.classList.remove('cursor-pipette');
            }
        }

        function pickColor(e) {
            // å¾ Preview Canvas (åº•åœ–) å–è‰²
            const pCanvas = document.getElementById('previewCanvas');
            const pCtx = pCanvas.getContext('2d');
            const point = getCanvasPoint(e, pCanvas);
            
            // è®€å–åƒç´ 
            const pixel = pCtx.getImageData(point.x, point.y, 1, 1).data;
            const hex = "#" + ((1 << 24) + (pixel[0] << 16) + (pixel[1] << 8) + pixel[2]).toString(16).slice(1);
            
            // è¨­å®šé¡è‰²
            brushColorInput.value = hex;
            
            // é—œé–‰å¸ç®¡ï¼Œè‡ªå‹•åˆ‡å›ç­†åˆ·
            toggleEyedropper();
        }

        function startDrawing(e) {
            if (isEyedropperActive) {
                pickColor(e);
                return;
            }
            isDrawing = true;
            const point = getCanvasPoint(e, maskCanvas);
            [lastX, lastY] = [point.x, point.y];
        }

        function draw(e) {
            if (!isDrawing) return;
            const point = getCanvasPoint(e, maskCanvas);
            drawStroke(point.x, point.y);
        }

        function drawStroke(x, y) {
            maskCtx.lineJoin = 'round';
            maskCtx.lineCap = 'round';
            maskCtx.lineWidth = brushSizeInput.value;
            maskCtx.strokeStyle = brushColorInput.value;
            
            maskCtx.beginPath();
            maskCtx.moveTo(lastX, lastY);
            maskCtx.lineTo(x, y);
            maskCtx.stroke();
            
            [lastX, lastY] = [x, y];
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                if (currentPageIndex !== -1) {
                    pdfPages[currentPageIndex].maskData = maskCanvas.toDataURL();
                }
            }
        }

        function clearMask() {
            maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            if (currentPageIndex !== -1) {
                pdfPages[currentPageIndex].maskData = null;
            }
        }

        function toggleRangeInput() {
            const isCustom = document.querySelector('input[name="rangeType"][value="custom"]').checked;
            customRangeInput.disabled = !isCustom;
            if (isCustom) customRangeInput.focus();
        }

        function parsePageRange(str, totalPages) {
            if (!str || !str.trim()) return [];
            const pages = new Set();
            const parts = str.split(',');
            for (let part of parts) {
                part = part.trim();
                if (part.includes('-')) {
                    const [start, end] = part.split('-').map(Number);
                    if (!isNaN(start) && !isNaN(end)) {
                        for (let i = start; i <= end; i++) pages.add(i);
                    }
                } else {
                    const num = Number(part);
                    if (!isNaN(num)) pages.add(num);
                }
            }
            return Array.from(pages)
                .filter(p => p >= 1 && p <= totalPages)
                .map(p => p - 1)
                .sort((a, b) => a - b);
        }

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (file.type !== 'application/pdf') {
                alert('è«‹ä¸Šå‚³ PDF æª”æ¡ˆ');
                return;
            }

            const fileReader = new FileReader();
            fileReader.onload = async function() {
                const typedarray = new Uint8Array(this.result);
                try {
                    statusMsg.textContent = 'æ­£åœ¨è®€å– PDF...';
                    statusMsg.classList.remove('hidden');
                    
                    pdfDoc = await pdfjsLib.getDocument(typedarray).promise;
                    document.getElementById('pageCount').textContent = `å…± ${pdfDoc.numPages} é `;
                    document.getElementById('controlPanel').classList.remove('hidden');
                    document.getElementById('rangeSelector').classList.remove('hidden');
                    
                    await renderPageThumbnails();
                    
                    statusMsg.textContent = 'PDF è¼‰å…¥å®Œæˆï¼Œè«‹é¸æ“‡é é¢é–‹å§‹å¡—æ”¹æˆ–è‡ªå‹•åˆ†æ';
                    setTimeout(() => statusMsg.classList.add('hidden'), 3000);
                    
                } catch (error) {
                    console.error(error);
                    alert('è®€å– PDF å¤±æ•—ï¼š' + error.message);
                }
            };
            fileReader.readAsArrayBuffer(file);
        });

        async function renderPageThumbnails() {
            pagesList.innerHTML = '';
            pdfPages = [];

            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const page = await pdfDoc.getPage(i);
                const viewport = page.getViewport({ scale: 0.3 }); 
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                canvas.className = 'w-full h-auto border rounded mb-2 bg-white';
                await page.render({ canvasContext: context, viewport: viewport }).promise;

                const card = document.createElement('div');
                card.className = 'page-card bg-white p-3 rounded shadow cursor-pointer hover:bg-gray-50';
                card.onclick = () => selectPage(i - 1);
                card.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-bold text-gray-600">Page ${i}</span>
                        <span class="status-badge text-xs px-2 py-0.5 rounded bg-gray-200 text-gray-600">å¾…æ©Ÿ</span>
                    </div>
                    <div class="thumb-container"></div>
                    <div class="mt-2 flex justify-between items-center">
                        <button onclick="analyzeSinglePage(${i-1}, event)" class="analyze-btn text-xs bg-blue-100 text-blue-600 px-2 py-1 rounded hover:bg-blue-200 w-full flex items-center justify-center gap-1">
                            <i data-lucide="sparkles" class="w-3 h-3"></i> åˆ†ææ­¤é 
                        </button>
                    </div>
                `;
                
                card.querySelector('.thumb-container').appendChild(canvas);
                pagesList.appendChild(card);
                lucide.createIcons({ root: card });

                pdfPages.push({
                    pageNum: i,
                    thumbnail: canvas.toDataURL('image/jpeg'),
                    status: 'idle',
                    data: null,
                    cardElement: card,
                    maskData: null // Store drawing here
                });
            }
        }

        async function selectPage(index) {
            // Save current mask
            if (currentPageIndex !== -1 && currentPageIndex !== index) {
                pdfPages[currentPageIndex].maskData = maskCanvas.toDataURL();
            }

            currentPageIndex = index;
            const pageData = pdfPages[index];

            document.querySelectorAll('.page-card').forEach(c => c.classList.remove('active'));
            pageData.cardElement.classList.add('active');
            emptyState.classList.add('hidden');
            previewArea.classList.remove('hidden');

            // Render Preview Canvas
            const page = await pdfDoc.getPage(pageData.pageNum);
            const viewport = page.getViewport({ scale: 1.0 });
            
            const pCanvas = document.getElementById('previewCanvas');
            const pCtx = pCanvas.getContext('2d');
            
            // Set dimensions for both canvases
            pCanvas.width = viewport.width;
            pCanvas.height = viewport.height;
            maskCanvas.width = viewport.width;
            maskCanvas.height = viewport.height;
            
            // Render PDF
            await page.render({ canvasContext: pCtx, viewport: viewport }).promise;

            // Restore Mask Data
            maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            if (pageData.maskData) {
                const img = new Image();
                img.onload = () => maskCtx.drawImage(img, 0, 0);
                img.src = pageData.maskData;
            }

            // Fill Form
            if (pageData.data) {
                slideTitle.value = pageData.data.title || '';
                slideContent.value = (pageData.data.content || []).join('\n');
                slideNotes.value = pageData.data.speaker_notes || '';
                updateStatusBadge('success');
            } else {
                slideTitle.value = '';
                slideContent.value = '';
                slideNotes.value = '';
                updateStatusBadge(pageData.status);
            }
        }

        function updateStatusBadge(status) {
            const badge = document.getElementById('currentStatusBadge');
            if (status === 'success') {
                badge.className = 'bg-green-100 text-green-700 px-3 py-1 rounded-full text-sm font-medium';
                badge.textContent = 'å·²å®Œæˆ';
            } else if (status === 'loading') {
                badge.className = 'bg-blue-100 text-blue-700 px-3 py-1 rounded-full text-sm font-medium';
                badge.textContent = 'åˆ†æä¸­...';
            } else if (status === 'error') {
                badge.className = 'bg-red-100 text-red-700 px-3 py-1 rounded-full text-sm font-medium';
                badge.textContent = 'å¤±æ•—';
            } else {
                badge.className = 'bg-gray-200 text-gray-700 px-3 py-1 rounded-full text-sm font-medium';
                badge.textContent = 'æœªåˆ†æ';
            }
        }

        async function analyzeSinglePage(index, event) {
            if (event) event.stopPropagation(); 
            
            const key = apiKeyInput.value.trim();
            if (!key) { alert('è«‹å…ˆè¼¸å…¥ Google Gemini API Key'); return false; }

            const pageItem = pdfPages[index];
            updatePageUI(index, 'loading');
            
            if (!isAutoRunning) selectPage(index); 

            try {
                const page = await pdfDoc.getPage(pageItem.pageNum);
                const viewport = page.getViewport({ scale: 1.0 }); 
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const ctx = canvas.getContext('2d');
                await page.render({ canvasContext: ctx, viewport: viewport }).promise;
                const base64Image = canvas.toDataURL('image/jpeg', 0.7).split(',')[1];

                const result = await callGeminiAPI(key, base64Image);
                
                pageItem.data = result;
                updatePageUI(index, 'success');
                
                if (currentPageIndex === index) {
                    slideTitle.value = result.title || '';
                    slideContent.value = (result.content || []).join('\n');
                    slideNotes.value = result.speaker_notes || '';
                }
                
                checkAllDone();
                return true;

            } catch (error) {
                console.error(error);
                updatePageUI(index, 'error');
                if (currentPageIndex === index) updateStatusBadge('error');
                if (!isAutoRunning) {
                    alert(`åˆ†æå¤±æ•—ï¼š${error.message}`);
                }
                return false;
            }
        }

        // V5 Core API Logic - Exactly as requested
        async function callGeminiAPI(key, base64Image) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${key}`;
            const prompt = `åˆ†æé€™å¼µç°¡å ±åœ–ç‰‡ï¼Œæå–å…§å®¹ä¸¦å›å‚³ç´” JSONã€‚åš´æ ¼æ ¼å¼ï¼š{"title": "æ¨™é¡Œ", "content": ["é‡é»1", "é‡é»2"], "speaker_notes": "å‚™å¿˜ç¨¿"}`;

            const payload = {
                contents: [{
                    role: "user",
                    parts: [
                        { text: prompt },
                        { inlineData: { mimeType: "image/jpeg", data: base64Image } }
                    ]
                }],
                generationConfig: { responseMimeType: "application/json" }
            };

            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const data = await response.json();
            
            if (!response.ok) {
                if (response.status === 429) throw new Error('Google æµé‡é™åˆ¶ (429)');
                throw new Error(data.error?.message || 'API è«‹æ±‚å¤±æ•—');
            }
            try {
                return JSON.parse(data.candidates[0].content.parts[0].text);
            } catch (e) {
                throw new Error('ç„¡æ³•è§£æ JSON');
            }
        }

        function updatePageUI(index, status) {
            const item = pdfPages[index];
            item.status = status;
            
            const badge = item.cardElement.querySelector('.status-badge');
            const btn = item.cardElement.querySelector('.analyze-btn');
            item.cardElement.classList.remove('done', 'error');

            if (status === 'loading') {
                badge.className = 'status-badge text-xs px-2 py-0.5 rounded bg-blue-100 text-blue-700';
                badge.innerHTML = '<div class="loader inline-block align-middle mr-1" style="width:12px;height:12px;"></div>';
                btn.disabled = true;
                btn.textContent = '...';
            } else if (status === 'success') {
                item.cardElement.classList.add('done');
                badge.className = 'status-badge text-xs px-2 py-0.5 rounded bg-green-100 text-green-700';
                badge.textContent = 'å®Œæˆ';
                btn.disabled = false;
                btn.innerHTML = '<i data-lucide="refresh-cw" class="w-3 h-3 inline"></i> é‡åš';
                lucide.createIcons({ root: item.cardElement });
            } else if (status === 'error') {
                item.cardElement.classList.add('error');
                badge.className = 'status-badge text-xs px-2 py-0.5 rounded bg-red-100 text-red-700';
                badge.textContent = 'å¤±æ•—';
                btn.disabled = false;
                btn.innerHTML = '<i data-lucide="refresh-cw" class="w-3 h-3 inline"></i> é‡è©¦';
                lucide.createIcons({ root: item.cardElement });
            }
        }

        function saveCurrentSlide() {
            if (currentPageIndex === -1) return;
            const item = pdfPages[currentPageIndex];
            
            // Save mask
            item.maskData = maskCanvas.toDataURL();
            
            if (!item.data) item.data = {};
            item.data.title = slideTitle.value;
            item.data.content = slideContent.value.split('\n').filter(line => line.trim() !== '');
            item.data.speaker_notes = slideNotes.value;
            
            if (item.status !== 'success') updatePageUI(currentPageIndex, 'success');
            checkAllDone();
            
            const btn = document.querySelector('button[onclick="saveCurrentSlide()"]');
            const originalHTML = btn.innerHTML;
            btn.textContent = 'å·²å„²å­˜ï¼';
            btn.className = 'bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 flex items-center gap-2';
            setTimeout(() => {
                btn.innerHTML = originalHTML;
                btn.className = 'bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 flex items-center gap-2';
                lucide.createIcons({ root: btn });
            }, 1000);
        }

        function checkAllDone() {
            const hasSuccess = pdfPages.some(p => p.status === 'success');
            document.getElementById('downloadBtn').disabled = !hasSuccess;
        }

        async function startAutoRun() {
            const key = apiKeyInput.value.trim();
            if (!key) { alert('è«‹è¼¸å…¥ API Key'); return; }

            let pagesToProcess = [];
            const rangeType = document.querySelector('input[name="rangeType"]:checked').value;
            
            if (rangeType === 'all') {
                pagesToProcess = pdfPages.map((_, i) => i); 
            } else {
                const inputStr = customRangeInput.value;
                pagesToProcess = parsePageRange(inputStr, pdfPages.length);
                if (pagesToProcess.length === 0) {
                    alert('è«‹è¼¸å…¥æœ‰æ•ˆçš„é æ•¸ç¯„åœ');
                    return;
                }
            }

            isAutoRunning = true;
            document.getElementById('autoRunBtn').classList.add('hidden');
            document.getElementById('stopBtn').classList.remove('hidden');
            statusMsg.classList.remove('hidden');

            for (let i = 0; i < pdfPages.length; i++) {
                if (!isAutoRunning) break;
                if (!pagesToProcess.includes(i)) continue;
                if (pdfPages[i].status === 'success') continue; 

                statusMsg.textContent = `è‡ªå‹•åˆ†æç¬¬ ${i+1} é ...`;
                pdfPages[i].cardElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

                const success = await analyzeSinglePage(i);
                
                if (!success) {
                    for(let t=60; t>0; t--) {
                        if(!isAutoRunning) break;
                        statusMsg.textContent = `âš ï¸ ç¬¬ ${i+1} é å¤±æ•— (é¿é–‹æµé‡é™åˆ¶)ï¼Œä¼‘æ¯ ${t} ç§’å¾Œé‡è©¦...`;
                        await wait(1000);
                    }
                    if(isAutoRunning) i--; 
                } else {
                    if (i < pdfPages.length - 1) {
                         for(let t=15; t>0; t--) { 
                             if(!isAutoRunning) break;
                             statusMsg.textContent = `âœ… ç¬¬ ${i+1} é å®Œæˆï¼Œå†·å» ${t} ç§’...`;
                             await wait(1000);
                         }
                    }
                }
            }
            stopAutoRun();
            statusMsg.textContent = 'åˆ†ææ’ç¨‹çµæŸ';
        }

        function stopAutoRun() {
            isAutoRunning = false;
            document.getElementById('autoRunBtn').classList.remove('hidden');
            document.getElementById('stopBtn').classList.add('hidden');
        }

        function wait(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

        async function exportPPT() {
            if (currentPageIndex !== -1) {
                 pdfPages[currentPageIndex].maskData = maskCanvas.toDataURL();
            }

            const pptx = new PptxGenJS();
            pptx.layout = 'LAYOUT_16x9';

            const useBg = useBgImageCheck.checked;

            if (useBg) {
                const btn = document.getElementById('downloadBtn');
                btn.disabled = true;
                btn.textContent = 'ç”Ÿæˆåœ–ç‰‡ä¸­...';
                await wait(100);
            }

            let count = 0;
            for (let index = 0; index < pdfPages.length; index++) {
                const page = pdfPages[index];
                if (page.status !== 'success' || !page.data) continue;
                count++;

                const slide = pptx.addSlide();
                const data = page.data;

                if (useBg && pdfDoc) {
                    try {
                        const pdfPage = await pdfDoc.getPage(page.pageNum);
                        const viewport = pdfPage.getViewport({ scale: 1.5 });
                        const canvas = document.createElement('canvas');
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        const ctx = canvas.getContext('2d');
                        await pdfPage.render({ canvasContext: ctx, viewport: viewport }).promise;
                        slide.background = { data: canvas.toDataURL('image/jpeg', 0.8) };
                    } catch (e) { console.error(e); }
                }

                if (page.maskData) {
                    slide.addImage({ 
                        data: page.maskData, 
                        x: 0, y: 0, w: '100%', h: '100%' 
                    });
                }

                slide.addText(data.title || `Slide ${index+1}`, { 
                    x: 0.5, y: 0.5, w: '90%', h: 1.2, 
                    fontSize: 24, bold: true, color: '363636', fontFace: 'Arial',
                    align: 'center'
                });

                if (data.content && data.content.length > 0) {
                    const items = data.content.map(text => ({ text: text, options: { fontSize: 18, breakLine: true } }));
                    slide.addText(items, { 
                        x: 0.5, y: 1.8, w: '90%', h: 4.5, 
                        fontSize: 18, color: '505050', bullet: true, lineSpacing: 35,
                        valign: 'top'
                    });
                }

                if (data.speaker_notes) slide.addNotes(data.speaker_notes);
            }

            if (useBg) {
                 const btn = document.getElementById('downloadBtn');
                 btn.innerHTML = '<i data-lucide="download" class="w-4 h-4"></i><span> ä¸‹è¼‰ PPT</span>';
                 btn.disabled = false;
                 if (typeof lucide !== 'undefined') lucide.createIcons({ root: document.getElementById('downloadBtn') });
            }

            if (count === 0) { alert('æ²’æœ‰å¯åŒ¯å‡ºçš„é é¢'); return; }
            pptx.writeFile({ fileName: 'NotebookLM_Restored.pptx' });
        }
    </script>
</body>
</html>
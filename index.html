<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NotebookLM PDF è½‰ PPT ç°¡å ±ç”Ÿæˆå™¨ (V15 å®Œæ•´éŸ¿æ‡‰ç‰ˆ)</title>
    
    <!-- PWA è¨­å®š -->
    <link rel="manifest" href="manifest.json">
    <script>
      // åªåœ¨ http æˆ– https å”è­°ä¸‹è¨»å†Š Service Workerï¼Œé¿å…é è¦½ç’°å¢ƒå ±éŒ¯
      if ('serviceWorker' in navigator && (window.location.protocol === 'https:' || window.location.protocol === 'http:')) {
        navigator.serviceWorker.register('sw.js').catch(err => {
            console.log('Service Worker è¨»å†Šå¤±æ•— (é è¦½æ¨¡å¼ä¸‹æ­£å¸¸):', err);
        });
      }
    </script>
    
    <!-- å¼•å…¥å¿…è¦çš„å‡½å¼åº« -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        body { font-family: 'Noto Sans TC', sans-serif; background-color: #f3f4f6; }
        
        /* é é¢å¡ç‰‡æ¨£å¼ */
        .page-card { transition: all 0.3s ease; }
        .page-card.active { border: 2px solid #3b82f6; box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.5); }
        .page-card.done { border-color: #10b981; background-color: #ecfdf5; }
        .page-card.error { border-color: #ef4444; background-color: #fef2f2; }
        
        /* é˜²æ­¢ç•«å¸ƒæ“ä½œæ™‚æ²å‹•é é¢ */
        canvas { touch-action: none; }
        
        /* å¸ç®¡æ¨¡å¼æ¸¸æ¨™ */
        .cursor-pipette { cursor: crosshair !important; }

        /* æ‰‹æ©Ÿç‰ˆå„ªåŒ–ï¼šéš±è—æ²è»¸ä½†ä¿ç•™åŠŸèƒ½ */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        .loader {
            border: 3px solid #f3f3f3;
            border-radius: 50%;
            border-top: 3px solid #3b82f6;
            width: 20px;
            height: 20px;
            -webkit-animation: spin 1s linear infinite; /* Safari */
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden text-gray-800">

    <!-- Header (éŸ¿æ‡‰å¼èª¿æ•´ï¼šæ‰‹æ©Ÿç‰ˆç›´æ’ï¼Œé›»è…¦ç‰ˆæ©«æ’) -->
    <header class="bg-white shadow-sm z-20 p-3 flex flex-col md:flex-row justify-between gap-3 shrink-0">
        <div class="flex justify-between items-center">
            <div class="flex items-center gap-2">
                <div class="bg-blue-600 text-white p-1.5 rounded-lg font-bold text-lg">N</div>
                <h1 class="text-lg font-bold text-gray-800 truncate">PDF è½‰ PPT <span class="text-xs font-normal text-gray-500 bg-gray-100 px-2 py-0.5 rounded">æ‰‹æ©Ÿç‰ˆ</span></h1>
            </div>
        </div>
        
        <div class="flex flex-wrap gap-2 items-center justify-between md:justify-end">
            <!-- API Key è¼¸å…¥ -->
            <div class="flex flex-col items-end w-full md:w-auto">
                <label class="text-xs text-gray-500 mb-1 hidden md:block">Google Gemini API Key</label>
                <input type="password" id="apiKey" class="border rounded px-2 py-1.5 text-xs w-full md:w-64 focus:outline-none focus:border-blue-500" placeholder="è²¼ä¸Šæ‚¨çš„ API Key (AIza...)">
            </div>
            
            <div class="flex gap-2 w-full md:w-auto">
                <label class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1.5 rounded cursor-pointer transition flex items-center justify-center gap-2 flex-1 md:flex-none text-sm shadow-sm">
                    <i data-lucide="folder-open" class="w-4 h-4"></i>
                    <span>PDF</span>
                    <input type="file" id="pdfInput" accept=".pdf" class="hidden">
                </label>
                <button id="downloadBtn" onclick="exportPPT()" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1.5 rounded disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2 flex-1 md:flex-none text-sm shadow-sm" disabled>
                    <i data-lucide="download" class="w-4 h-4"></i>
                    <span>ä¸‹è¼‰</span>
                </button>
            </div>
        </div>
        
        <!-- èªªæ˜èˆ‡é¸é … -->
        <div class="flex justify-between md:justify-end gap-4 text-xs text-gray-600 bg-gray-50 p-2 rounded border border-gray-100 items-center">
            <span class="hidden md:inline">ğŸ’¡ å¸ç®¡å–è‰² -> ç­†åˆ·é®è“‹ -> è‡ªå‹•åˆ†æ</span>
            <label class="flex items-center gap-2 cursor-pointer hover:text-blue-600 pl-2">
                <input type="checkbox" id="useBgImageDesktop" class="rounded text-blue-600 focus:ring-blue-500" checked onchange="syncOptions(this)">
                <span>ä¿ç•™åº•åœ–</span>
            </label>
            <!-- æ‰‹æ©Ÿç‰ˆéš±è—é¸é …åŒæ­¥ -->
            <input type="checkbox" id="useBgImageMobile" class="hidden" checked onchange="syncOptions(this)">
        </div>
    </header>

    <!-- Main Content (éŸ¿æ‡‰å¼èª¿æ•´ï¼šæ‰‹æ©Ÿç‰ˆä¸Šä¸‹æ’ï¼Œé›»è…¦ç‰ˆå·¦å³æ’) -->
    <main class="flex-1 flex flex-col md:flex-row overflow-hidden relative">
        
        <!-- Left Panel: Page List -->
        <!-- æ‰‹æ©Ÿç‰ˆï¼šä¸Šæ–¹æ©«å‘æ²å‹• / é›»è…¦ç‰ˆï¼šå·¦å´ç›´å¼åˆ—è¡¨ -->
        <div class="w-full md:w-80 bg-white border-b md:border-b-0 md:border-r flex flex-col shrink-0 transition-all duration-300 z-10" id="leftPanel">
            
            <!-- æ§åˆ¶å€ -->
            <div class="p-2 md:p-3 bg-gray-50 border-b flex justify-between items-center gap-2">
                <div class="flex items-center gap-2 overflow-hidden">
                    <span id="pageCount" class="font-bold text-gray-700 text-sm whitespace-nowrap">ç­‰å¾…æª”æ¡ˆ...</span>
                    <div id="statusMsg" class="bg-yellow-100 text-yellow-800 text-[10px] px-2 py-0.5 rounded hidden truncate">å°±ç·’</div>
                </div>
                
                <!-- Range & Auto Run -->
                <div id="controlPanel" class="hidden flex gap-1 items-center">
                    <div id="rangeSelector" class="flex gap-2 text-xs items-center mr-2 hidden md:flex">
                        <label class="cursor-pointer flex items-center gap-1"><input type="radio" name="rangeType" value="all" checked onchange="toggleRangeInput()"> å…¨éƒ¨</label>
                        <label class="cursor-pointer flex items-center gap-1"><input type="radio" name="rangeType" value="custom" onchange="toggleRangeInput()"> æŒ‡å®š</label>
                        <input type="text" id="customRangeInput" disabled placeholder="1,3-5" class="border rounded px-1 w-16 text-xs disabled:bg-gray-200">
                    </div>
                    
                    <button id="autoRunBtn" onclick="startAutoRun()" class="bg-indigo-600 hover:bg-indigo-700 text-white text-xs px-2 py-1.5 rounded flex items-center gap-1 shadow-sm">
                        <i data-lucide="rocket" class="w-3 h-3"></i> <span class="hidden sm:inline">è‡ªå‹•</span>
                    </button>
                    <button id="stopBtn" onclick="stopAutoRun()" class="hidden bg-red-500 text-white text-xs px-2 py-1.5 rounded">
                        <i data-lucide="square" class="w-3 h-3"></i>
                    </button>
                </div>
            </div>
            
            <!-- é é¢åˆ—è¡¨ -->
            <div id="pagesList" class="flex-1 overflow-x-auto md:overflow-x-hidden md:overflow-y-auto p-2 flex flex-row md:flex-col gap-2 bg-gray-100 md:bg-white min-h-[100px] md:min-h-0">
                <div class="text-center text-gray-400 text-xs w-full py-4">è«‹å…ˆä¸Šå‚³ PDF</div>
            </div>
        </div>

        <!-- Right Panel: Editor -->
        <div class="flex-1 bg-gray-50 flex flex-col relative overflow-hidden">
            
            <!-- Editor Container (ç½®ä¸­) -->
            <div id="previewArea" class="flex-1 flex flex-col p-2 md:p-6 overflow-y-auto hidden">
                
                <!-- Top Toolbar (å·¥å…·åˆ—ï¼šéŸ¿æ‡‰å¼æ›è¡Œ) -->
                <div class="flex flex-wrap items-center justify-between gap-2 mb-2 bg-white p-2 rounded shadow-sm sticky top-0 z-30">
                    <div class="flex items-center gap-2">
                        <h2 class="text-sm font-bold text-gray-800 hidden sm:block">ç·¨è¼¯</h2>
                        <span id="currentStatusBadge" class="bg-gray-200 text-gray-600 px-2 py-0.5 rounded text-xs">æœªåˆ†æ</span>
                    </div>
                    
                    <!-- Brush Tools -->
                    <div class="flex items-center gap-1 sm:gap-2 flex-wrap">
                        <span class="text-xs font-bold text-gray-600 flex items-center gap-1 hidden sm:flex">
                            <i data-lucide="brush" class="w-3 h-3"></i>
                        </span>
                        
                        <button id="eyedropperBtn" onclick="toggleEyedropper()" class="p-1.5 border rounded bg-gray-50 hover:bg-gray-100 text-gray-700 transition-colors" title="å¸ç®¡">
                            <i data-lucide="pipette" class="w-4 h-4"></i>
                        </button>

                        <input type="color" id="brushColor" value="#FFFFFF" class="h-7 w-8 p-0 border rounded cursor-pointer" title="ç­†åˆ·é¡è‰²">
                        <input type="range" id="brushSize" min="5" max="50" value="20" class="w-16 sm:w-24" title="ç­†åˆ·ç²—ç´°">
                        
                        <button onclick="clearMask()" class="text-xs bg-white border px-2 py-1.5 rounded text-red-600 flex items-center gap-1 shadow-sm ml-1">
                            <i data-lucide="trash-2" class="w-3 h-3"></i> <span class="hidden sm:inline">æ¸…é™¤</span>
                        </button>
                    </div>
                </div>

                <!-- Canvas Area (éŸ¿æ‡‰å¼å®¹å™¨ï¼Œgrid æ’ç‰ˆ) -->
                <div class="w-full grid grid-cols-1 lg:grid-cols-5 gap-4">
                    
                    <!-- åœ–ç‰‡èˆ‡ç•«å¸ƒ (ä½”æ»¿æˆ–ä½” 3/5) -->
                    <div class="col-span-1 lg:col-span-3">
                        <div class="relative border rounded-lg bg-gray-200 overflow-hidden flex justify-center items-center shadow-inner" style="min-height: 300px; max-height: 70vh;">
                            <!-- PDF Layer -->
                            <canvas id="previewCanvas" class="absolute z-10 shadow-sm" style="max-width: 100%; max-height: 100%; object-fit: contain;"></canvas>
                            <!-- Mask Layer (For drawing) -->
                            <canvas id="maskCanvas" class="absolute z-20 cursor-crosshair touch-none" style="max-width: 100%; max-height: 100%; object-fit: contain;"></canvas>
                        </div>
                    </div>

                    <!-- è¡¨å–® (ä½”æ»¿æˆ–ä½” 2/5) -->
                    <div class="col-span-1 lg:col-span-2 space-y-3 bg-white p-3 rounded shadow-sm h-fit">
                        <div>
                            <label class="block text-xs font-bold text-gray-500 mb-1">æ¨™é¡Œ</label>
                            <input type="text" id="slideTitle" class="w-full border rounded px-2 py-1.5 text-sm focus:border-blue-500 outline-none bg-gray-50 focus:bg-white">
                        </div>
                        <div>
                            <label class="block text-xs font-bold text-gray-500 mb-1">å…§æ–‡ (è‡ªå‹•åˆ†æçµæœ)</label>
                            <textarea id="slideContent" rows="6" class="w-full border rounded px-2 py-1.5 text-sm focus:border-blue-500 outline-none bg-gray-50 focus:bg-white resize-y"></textarea>
                        </div>
                        <div>
                            <label class="block text-xs font-bold text-gray-500 mb-1">å‚™å¿˜ç¨¿</label>
                            <textarea id="slideNotes" rows="2" class="w-full border rounded px-2 py-1.5 text-sm bg-yellow-50 focus:bg-white outline-none"></textarea>
                        </div>
                        <div class="flex justify-end pt-2">
                            <button onclick="saveCurrentSlide()" class="bg-blue-600 active:bg-blue-700 text-white px-6 py-2 rounded text-sm font-bold shadow-md flex items-center gap-2 w-full sm:w-auto justify-center">
                                <i data-lucide="save" class="w-4 h-4"></i> ä¿å­˜æ­¤é 
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Spacer -->
                <div class="h-10"></div>
            </div>

            <!-- Empty State -->
            <div id="emptyState" class="flex-1 flex flex-col items-center justify-center text-gray-400 p-8">
                <i data-lucide="mouse-pointer-click" class="w-12 h-12 mb-2 opacity-50"></i>
                <p class="text-sm">è«‹é¸æ“‡ä¸Šæ–¹é é¢é–‹å§‹ç·¨è¼¯</p>
            </div>
        </div>
    </main>

    <!-- JS Logic -->
    <script>
        // Init Icons
        if (typeof lucide !== 'undefined') lucide.createIcons();
        
        // --- è®Šæ•¸èˆ‡ç‹€æ…‹ ---
        let pdfDoc = null;
        let pdfPages = []; 
        let currentPageIndex = -1;
        let isAutoRunning = false;

        // ç•«å¸ƒè®Šæ•¸
        let isDrawing = false;
        let isEyedropperActive = false; // å¸ç®¡ç‹€æ…‹
        let lastX = 0;
        let lastY = 0;
        const maskCanvas = document.getElementById('maskCanvas');
        const maskCtx = maskCanvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');

        // UI å…ƒç´ 
        const apiKeyInput = document.getElementById('apiKey');
        const fileInput = document.getElementById('pdfInput');
        const pagesList = document.getElementById('pagesList');
        const previewArea = document.getElementById('previewArea');
        const emptyState = document.getElementById('emptyState');
        const statusMsg = document.getElementById('statusMsg');
        const brushColorInput = document.getElementById('brushColor');
        const brushSizeInput = document.getElementById('brushSize');
        const eyedropperBtn = document.getElementById('eyedropperBtn');

        // åŒæ­¥æ‰‹æ©Ÿ/é›»è…¦ç‰ˆé¸é …
        function syncOptions(el) {
            const val = el.checked;
            document.getElementById('useBgImageDesktop').checked = val;
            document.getElementById('useBgImageMobile').checked = val;
        }

        // --- æ ¸å¿ƒï¼šåº§æ¨™è½‰æ› (æ”¯æ´ RWD ç¸®æ”¾) ---
        // é€™æ˜¯è§£æ±ºæ‰‹æ©Ÿä¸Šã€Œé»ä¸åˆ°ä½ã€çš„é—œéµå‡½å¼
        function getCanvasPoint(e, canvas) {
            const rect = canvas.getBoundingClientRect();
            // è¨ˆç®— Canvas å¯¦éš›åƒç´ èˆ‡é¡¯ç¤ºå¤§å°çš„æ¯”ä¾‹
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // æ”¯æ´æ»‘é¼ èˆ‡è§¸æ§
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // Setup Drawing Events
        maskCanvas.addEventListener('mousedown', startDrawing);
        maskCanvas.addEventListener('mousemove', draw);
        maskCanvas.addEventListener('mouseup', stopDrawing);
        maskCanvas.addEventListener('mouseout', stopDrawing);
        
        // Touch support
        maskCanvas.addEventListener('touchstart', (e) => {
            if (e.target === maskCanvas) e.preventDefault(); 
            startDrawing(e);
        }, { passive: false });
        
        maskCanvas.addEventListener('touchmove', (e) => {
            if (e.target === maskCanvas) e.preventDefault();
            draw(e);
        }, { passive: false });
        
        maskCanvas.addEventListener('touchend', stopDrawing);

        // --- å¸ç®¡åŠŸèƒ½é‚è¼¯ ---
        function toggleEyedropper() {
            isEyedropperActive = !isEyedropperActive;
            if (isEyedropperActive) {
                eyedropperBtn.classList.add('bg-blue-100', 'border-blue-500', 'text-blue-600');
                maskCanvas.classList.add('cursor-pipette');
            } else {
                eyedropperBtn.classList.remove('bg-blue-100', 'border-blue-500', 'text-blue-600');
                maskCanvas.classList.remove('cursor-pipette');
            }
        }

        function pickColor(e) {
            // å¾ Preview Canvas (åº•åœ–) å–è‰²
            const pCanvas = document.getElementById('previewCanvas');
            const pCtx = pCanvas.getContext('2d');
            const point = getCanvasPoint(e, pCanvas);
            
            // è®€å–åƒç´ 
            try {
                const pixel = pCtx.getImageData(point.x, point.y, 1, 1).data;
                const hex = "#" + ((1 << 24) + (pixel[0] << 16) + (pixel[1] << 8) + pixel[2]).toString(16).slice(1);
                brushColorInput.value = hex;
            } catch(err) { console.error("Pick color error", err); }
            
            // é—œé–‰å¸ç®¡ï¼Œè‡ªå‹•åˆ‡å›ç­†åˆ·
            toggleEyedropper();
        }

        function startDrawing(e) {
            if (isEyedropperActive) {
                pickColor(e);
                return;
            }
            isDrawing = true;
            const point = getCanvasPoint(e, maskCanvas);
            [lastX, lastY] = [point.x, point.y];
        }

        function draw(e) {
            if (!isDrawing) return;
            const point = getCanvasPoint(e, maskCanvas);
            drawStroke(point.x, point.y);
        }

        function drawStroke(x, y) {
            maskCtx.lineJoin = 'round';
            maskCtx.lineCap = 'round';
            maskCtx.lineWidth = brushSizeInput.value;
            maskCtx.strokeStyle = brushColorInput.value;
            
            maskCtx.beginPath();
            maskCtx.moveTo(lastX, lastY);
            maskCtx.lineTo(x, y);
            maskCtx.stroke();
            
            [lastX, lastY] = [x, y];
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                if (currentPageIndex !== -1) {
                    pdfPages[currentPageIndex].maskData = maskCanvas.toDataURL();
                }
            }
        }

        function clearMask() {
            maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            if (currentPageIndex !== -1) {
                pdfPages[currentPageIndex].maskData = null;
            }
        }

        function toggleRangeInput() {
            const isCustom = document.querySelector('input[name="rangeType"][value="custom"]').checked;
            document.getElementById('customRangeInput').disabled = !isCustom;
            if (isCustom) document.getElementById('customRangeInput').focus();
        }

        function parsePageRange(str, totalPages) {
            if (!str || !str.trim()) return [];
            const pages = new Set();
            const parts = str.split(',');
            for (let part of parts) {
                part = part.trim();
                if (part.includes('-')) {
                    const [start, end] = part.split('-').map(Number);
                    if (!isNaN(start) && !isNaN(end)) {
                        for (let i = start; i <= end; i++) pages.add(i);
                    }
                } else {
                    const num = Number(part);
                    if (!isNaN(num)) pages.add(num);
                }
            }
            return Array.from(pages)
                .filter(p => p >= 1 && p <= totalPages)
                .map(p => p - 1)
                .sort((a, b) => a - b);
        }

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (file.type !== 'application/pdf') {
                alert('è«‹ä¸Šå‚³ PDF æª”æ¡ˆ');
                return;
            }

            const fileReader = new FileReader();
            fileReader.onload = async function() {
                const typedarray = new Uint8Array(this.result);
                try {
                    statusMsg.textContent = 'è®€å–ä¸­...';
                    statusMsg.classList.remove('hidden');
                    
                    pdfDoc = await pdfjsLib.getDocument(typedarray).promise;
                    document.getElementById('pageCount').textContent = `å…± ${pdfDoc.numPages} é `;
                    document.getElementById('controlPanel').classList.remove('hidden');
                    if(document.getElementById('rangeSelector')) document.getElementById('rangeSelector').classList.remove('hidden');
                    
                    await renderPageThumbnails();
                    
                    statusMsg.textContent = 'å®Œæˆ';
                    setTimeout(() => statusMsg.classList.add('hidden'), 3000);
                    
                } catch (error) {
                    console.error(error);
                    alert('è®€å– PDF å¤±æ•—ï¼š' + error.message);
                }
            };
            fileReader.readAsArrayBuffer(file);
        });

        async function renderPageThumbnails() {
            pagesList.innerHTML = '';
            pdfPages = [];

            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const page = await pdfDoc.getPage(i);
                const viewport = page.getViewport({ scale: 0.2 }); // Low res for thumbs
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                // canvas.className = 'w-full h-auto border rounded mb-2 bg-white';
                await page.render({ canvasContext: context, viewport: viewport }).promise;

                // Card (Responsive Width)
                const card = document.createElement('div');
                card.className = 'page-card bg-white p-2 rounded shadow shrink-0 cursor-pointer w-24 md:w-full flex flex-col items-center gap-1';
                card.onclick = () => selectPage(i - 1);
                card.innerHTML = `
                    <div class="flex justify-between items-center w-full">
                        <span class="font-bold text-gray-500 text-xs">P.${i}</span>
                        <span class="status-dot w-2 h-2 rounded-full bg-gray-300"></span>
                    </div>
                    <div class="thumb-container w-full rounded overflow-hidden border border-gray-200"></div>
                `;
                
                canvas.style.width = '100%'; canvas.style.height = 'auto';
                card.querySelector('.thumb-container').appendChild(canvas);
                pagesList.appendChild(card);
                
                // ç¢ºä¿åˆ—è¡¨å¡ç‰‡ä¹Ÿæœ‰åœ–ç¤ºæ”¯æ´
                if (typeof lucide !== 'undefined') lucide.createIcons({ root: card });

                pdfPages.push({
                    pageNum: i,
                    thumbnail: canvas.toDataURL('image/jpeg'),
                    status: 'idle',
                    data: null,
                    cardElement: card,
                    maskData: null
                });
            }
        }

        async function selectPage(index) {
            if (currentPageIndex !== -1 && currentPageIndex !== index) {
                pdfPages[currentPageIndex].maskData = maskCanvas.toDataURL();
            }

            currentPageIndex = index;
            const pageData = pdfPages[index];

            document.querySelectorAll('.page-card').forEach(c => c.classList.remove('active'));
            pageData.cardElement.classList.add('active');
            
            emptyState.classList.add('hidden');
            previewArea.classList.remove('hidden');

            // Render Preview Canvas
            const page = await pdfDoc.getPage(pageData.pageNum);
            // æ‰‹æ©Ÿä¸Š scale 1.0 å°±å¤ æ¸…æ¥šäº†ï¼Œå¤ªå¤§æœƒlagï¼Œé€™è£¡è¨­ 1.5 ä¿æŒå“è³ª
            const viewport = page.getViewport({ scale: 1.5 });
            
            previewCanvas.width = viewport.width;
            previewCanvas.height = viewport.height;
            maskCanvas.width = viewport.width;
            maskCanvas.height = viewport.height;
            
            const pCtx = previewCanvas.getContext('2d');
            await page.render({ canvasContext: pCtx, viewport: viewport }).promise;

            maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            if (pageData.maskData) {
                const img = new Image();
                img.onload = () => maskCtx.drawImage(img, 0, 0);
                img.src = pageData.maskData;
            }

            if (pageData.data) {
                document.getElementById('slideTitle').value = pageData.data.title || '';
                document.getElementById('slideContent').value = (pageData.data.content || []).join('\n');
                document.getElementById('slideNotes').value = pageData.data.speaker_notes || '';
                updateStatusBadge('success');
            } else {
                document.getElementById('slideTitle').value = '';
                document.getElementById('slideContent').value = '';
                document.getElementById('slideNotes').value = '';
                updateStatusBadge(pageData.status);
            }
        }

        function updateStatusBadge(status) {
            const badge = document.getElementById('currentStatusBadge');
            const dot = pdfPages[currentPageIndex]?.cardElement.querySelector('.status-dot');
            
            if (status === 'success') {
                badge.className = 'bg-green-100 text-green-700 px-2 py-0.5 rounded text-xs';
                badge.textContent = 'å·²å®Œæˆ';
                if(dot) dot.className = 'status-dot w-2 h-2 rounded-full bg-green-500';
            } else if (status === 'loading') {
                badge.className = 'bg-blue-100 text-blue-700 px-2 py-0.5 rounded text-xs';
                badge.textContent = 'åˆ†æä¸­...';
                if(dot) dot.className = 'status-dot w-2 h-2 rounded-full bg-blue-500 animate-pulse';
            } else if (status === 'error') {
                badge.className = 'bg-red-100 text-red-700 px-2 py-0.5 rounded text-xs';
                badge.textContent = 'å¤±æ•—';
                if(dot) dot.className = 'status-dot w-2 h-2 rounded-full bg-red-500';
            } else {
                badge.className = 'bg-gray-200 text-gray-600 px-2 py-0.5 rounded text-xs';
                badge.textContent = 'æœªåˆ†æ';
                if(dot) dot.className = 'status-dot w-2 h-2 rounded-full bg-gray-300';
            }
        }

        // --- V5 Core API (Gemini 2.5) ---
        async function analyzeSinglePage(index, event) {
            if (event) event.stopPropagation(); 
            
            const key = apiKeyInput.value.trim();
            if (!key) { alert('è«‹å…ˆè¼¸å…¥ Google Gemini API Key'); return false; }

            const pageItem = pdfPages[index];
            updatePageUI(index, 'loading');
            
            if (!isAutoRunning) selectPage(index); 

            try {
                const page = await pdfDoc.getPage(pageItem.pageNum);
                const viewport = page.getViewport({ scale: 1.0 }); 
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const ctx = canvas.getContext('2d');
                await page.render({ canvasContext: ctx, viewport: viewport }).promise;
                // V5 Setting: 0.7 quality
                const base64Image = canvas.toDataURL('image/jpeg', 0.7).split(',')[1];

                const result = await callGeminiAPI(key, base64Image);
                
                pageItem.data = result;
                updatePageUI(index, 'success');
                
                if (currentPageIndex === index) {
                    document.getElementById('slideTitle').value = result.title || '';
                    document.getElementById('slideContent').value = (result.content || []).join('\n');
                    document.getElementById('slideNotes').value = result.speaker_notes || '';
                }
                
                checkAllDone();
                return true;

            } catch (error) {
                console.error(error);
                updatePageUI(index, 'error');
                if (currentPageIndex === index) updateStatusBadge('error');
                if (!isAutoRunning) {
                    alert(`åˆ†æå¤±æ•—ï¼š${error.message}`);
                }
                return false;
            }
        }

        async function callGeminiAPI(key, base64Image) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${key}`;
            const prompt = `åˆ†æé€™å¼µç°¡å ±åœ–ç‰‡ï¼Œæå–å…§å®¹ä¸¦å›å‚³ç´” JSONã€‚åš´æ ¼æ ¼å¼ï¼š{"title": "æ¨™é¡Œ", "content": ["é‡é»1", "é‡é»2"], "speaker_notes": "å‚™å¿˜ç¨¿"}`;

            const payload = {
                contents: [{
                    role: "user",
                    parts: [
                        { text: prompt },
                        { inlineData: { mimeType: "image/jpeg", data: base64Image } }
                    ]
                }],
                generationConfig: { responseMimeType: "application/json" }
            };

            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const data = await response.json();
            
            if (!response.ok) {
                if (response.status === 429) throw new Error('Google æµé‡é™åˆ¶ (429)');
                throw new Error(data.error?.message || 'API è«‹æ±‚å¤±æ•—');
            }
            try {
                return JSON.parse(data.candidates[0].content.parts[0].text);
            } catch (e) {
                throw new Error('ç„¡æ³•è§£æ JSON');
            }
        }

        function updatePageUI(index, status) {
            const item = pdfPages[index];
            item.status = status;
            
            const badge = item.cardElement.querySelector('.status-badge');
            // Logic handled in updateStatusBadge mainly for current view
            
            const dot = item.cardElement.querySelector('.status-dot');
            if(status === 'success') dot.className = 'status-dot w-2 h-2 rounded-full bg-green-500';
            else if(status === 'error') dot.className = 'status-dot w-2 h-2 rounded-full bg-red-500';
            else if(status === 'loading') dot.className = 'status-dot w-2 h-2 rounded-full bg-blue-500 animate-pulse';
        }

        function saveCurrentSlide() {
            if (currentPageIndex === -1) return;
            const item = pdfPages[currentPageIndex];
            item.maskData = maskCanvas.toDataURL();
            
            if (!item.data) item.data = {};
            item.data.title = document.getElementById('slideTitle').value;
            item.data.content = document.getElementById('slideContent').value.split('\n').filter(line => line.trim() !== '');
            item.data.speaker_notes = document.getElementById('slideNotes').value;
            
            if (item.status !== 'success') {
                item.status = 'success';
                updateStatusBadge('success');
            }
            checkAllDone();
            
            const btn = document.querySelector('button[onclick="saveCurrentSlide()"]');
            const originalHTML = btn.innerHTML;
            btn.textContent = 'å·²å„²å­˜ï¼';
            setTimeout(() => { btn.innerHTML = originalHTML; if(typeof lucide!=='undefined') lucide.createIcons({root:btn}); }, 1000);
        }

        function checkAllDone() {
            const hasSuccess = pdfPages.some(p => p.status === 'success');
            document.getElementById('downloadBtn').disabled = !hasSuccess;
        }

        async function startAutoRun() {
            const key = apiKeyInput.value.trim();
            if (!key) { alert('è«‹è¼¸å…¥ API Key'); return; }

            let pagesToProcess = [];
            const rangeType = document.querySelector('input[name="rangeType"]:checked').value;
            
            if (rangeType === 'all') {
                pagesToProcess = pdfPages.map((_, i) => i); 
            } else {
                const inputStr = document.getElementById('customRangeInput').value;
                pagesToProcess = parsePageRange(inputStr, pdfPages.length);
                if (pagesToProcess.length === 0) {
                    alert('è«‹è¼¸å…¥æœ‰æ•ˆçš„é æ•¸ç¯„åœ');
                    return;
                }
            }

            isAutoRunning = true;
            document.getElementById('autoRunBtn').classList.add('hidden');
            document.getElementById('stopBtn').classList.remove('hidden');
            statusMsg.classList.remove('hidden');

            for (let i = 0; i < pdfPages.length; i++) {
                if (!isAutoRunning) break;
                if (!pagesToProcess.includes(i)) continue;
                if (pdfPages[i].status === 'success') continue; 

                statusMsg.textContent = `è‡ªå‹•åˆ†æç¬¬ ${i+1} é ...`;
                pdfPages[i].cardElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

                await analyzeSinglePage(i);
                
                // Simple wait to prevent 429
                if (isAutoRunning) await new Promise(r => setTimeout(r, 2000));
            }
            stopAutoRun();
            statusMsg.textContent = 'åˆ†ææ’ç¨‹çµæŸ';
        }

        function stopAutoRun() {
            isAutoRunning = false;
            document.getElementById('autoRunBtn').classList.remove('hidden');
            document.getElementById('stopBtn').classList.add('hidden');
        }

        async function exportPPT() {
            if (currentPageIndex !== -1) pdfPages[currentPageIndex].maskData = maskCanvas.toDataURL();
            
            const btn = document.getElementById('downloadBtn');
            btn.disabled = true;
            btn.textContent = 'è™•ç†ä¸­...';

            const pptx = new PptxGenJS();
            pptx.layout = 'LAYOUT_16x9';
            
            const useBgDesktop = document.getElementById('useBgImageDesktop');
            const useBgMobile = document.getElementById('useBgImageMobile');
            // æª¢æŸ¥æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœéƒ½ä¸å­˜åœ¨(ç†è«–ä¸Šä¸æ‡‰è©²)ï¼Œé è¨­ true
            const useBg = (useBgDesktop && useBgDesktop.checked) || (useBgMobile && useBgMobile.checked);

            for (let i = 0; i < pdfPages.length; i++) {
                const page = pdfPages[i];
                if (page.status !== 'success' && !page.data) continue;

                const slide = pptx.addSlide();
                const data = page.data || {};

                if (useBg && pdfDoc) {
                    try {
                        const pdfPage = await pdfDoc.getPage(page.pageNum);
                        const viewport = pdfPage.getViewport({ scale: 1.5 });
                        const canvas = document.createElement('canvas');
                        canvas.width = viewport.width; canvas.height = viewport.height;
                        await pdfPage.render({ canvasContext: canvas.getContext('2d'), viewport: viewport }).promise;
                        slide.background = { data: canvas.toDataURL('image/jpeg', 0.8) };
                    } catch(e) {}
                }

                if (page.maskData) {
                    slide.addImage({ data: page.maskData, x: 0, y: 0, w: '100%', h: '100%' });
                }

                slide.addText(data.title || `Slide ${i+1}`, { 
                    x: 0.5, y: 0.5, w: '90%', h: 1.2, 
                    fontSize: 24, bold: true, color: '363636', fontFace: 'Arial', align: 'center' 
                });

                if (data.content && data.content.length > 0) {
                    const items = data.content.map(text => ({ text: text, options: { fontSize: 18, breakLine: true } }));
                    slide.addText(items, { 
                        x: 0.5, y: 1.8, w: '90%', h: 4.5, 
                        fontSize: 18, color: '505050', bullet: true, lineSpacing: 35, valign: 'top' 
                    });
                }
                
                if (data.speaker_notes) slide.addNotes(data.speaker_notes);
            }

            pptx.writeFile({ fileName: 'NotebookLM_Restored.pptx' });
            
            btn.disabled = false;
            btn.innerHTML = '<i data-lucide="download" class="w-4 h-4"></i> <span class="hidden md:inline">ä¸‹è¼‰ PPT</span><span class="md:hidden">ä¸‹è¼‰</span>';
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    </script>
</body>
</html>
